\documentclass{report}
\title{MoFASA: A Modular Framework for Auditing SCADA Applications}
\author{James Johnson}
\date{}
\begin{document}
\maketitle
\section*{Introduction}
This paper describes the MOdular Framework for Auditing SCADA Applications (MOFASA), a testing framework for
fuzzing embedded devices. In addition, it outlines the design of the framework and some more specialized
additions for covering the entire attack surface of a specific device.

Security practices in the field of embedded device programming lag behind those of more traditional realms
of software engineering. The causes of this are largely cultural. Embedded device programmers largely come
from electrical engineering backgrounds, and they in large part are not trained in secure software development.
Likewise, consumers rarely demand secure software practices from embedded device vendors, as they are simply
unaware of the risk presented by software vulnerabilities in modern embedded systems. Security testing is difficult,
and relegated to either expensive hardware testing solutions developed by boutique security companies, or skilled
individuals who are the employees of those same boutique security companies.

The goal of this framework is to change all that. By implementing a robust fault injection framework entirely
using free software and (relatively) inexpensive hardware, hopefully more consumers and vendors will take it
upon themselves to test their devices more rigorously, which will in turn create more awareness of the rampant
security problems in this application space.

\chapter{Background}
\section{Fuzzing Concepts}
Fuzzing is a technique of black box vulnerability testing that works by passing malformed data to an application
in order to attempt to test boundary conditions in the program.

The spiritual ancestor of fuzzing is an engineering practice called fault injection testing. In fault injection testing,
devices are tested for how they respond to error conditions such as faulty parts, or to environmental hazards like radiation,
electromagnetic pulses, and excessive heat or cold.

The idea for fuzzing as it exists today in computer security testing was arrived at by a University of Wisconsin professor who
attempted to log into a university terminal from his home using a remote terminal over a noisy connection. He noticed that the
connection distorted inputs that he specified to programs, and that these distortions caused odd behavior, including crashes
of some UNIX command-line utilities.

\subsection{Data Generation}
The first task for any fuzzing program or framework is to generate the malformed data that is fed to the target.
There are several different methods for accomplishing this task. The most basic is a random or ``dumb'' fuzzer,
which simply sends pseudo random data to the target in hopes of triggering a vulnerability. While this method
is inexact and attempts to cover an impractically large search space, it has successfully discovered vulnerabilities
in the past. Normally, however, one desires a more guided search of the space of potential inputs. 

One method of generating test cases is known as mutation-based fuzzing, which takes valid data and makes slight, 
random modifications in order to trigger error conditions in the target application. One advantage of this method
of data generation is that it requires little developer effort to begin testing of a target; one must simply provide
sample data for the framework to modify and send to the target. A disadvantage of this technique is that randomly
modifying a few bytes at a time leaves much of the possible space of test cases uncovered. Another disadvantage is that
this method can produce data that are \emph{too} malformed: many protocols, including the binary process control protocols
commonly used by the devices that MOFASA is designed to test, include checksums of data to ensure communication integrity.
Random modification of data can invalidate these checksums, which could result in the test case being rejected by the target.

The other commonly-used method of generating test data, and the one used by MOFASA, is known as template-based fuzzing. In this
model, a template for test data is specified by a programmer which the framework then uses to generate test cases. This technique
tends to yield greater code coverage than other data generation techniques, and it allows the developer to specify
bounds that ensure that the malformed nature of the test cases fall within acceptable limits so as to reduce the likelihood
of being prematurely rejected by the target.

Templates have been specified in many different ways, including the use of Backus-Naur Form to specify context-free grammars that use
production rules and annotations to generate complex test cases. The most common form in use by various frameworks today, including Sulley,
SPIKE, and PEACH, is block-based fuzzing. The most basic units of block-based fuzzing, at least as it is implemented in MoFASA, are primitive
elements such as integers, bit fields, and strings. Primitives can be assembled into blocks, which can be arranged to form complex messages
in a protocol. Operations such as cycling redundancy checks can be performed on blocks.

\subsection{Fault Detection}
Once a test case has triggered an error condition within the application, the testing framework needs to recognize the fact
that an error condition has been triggered and needs to record that fact, as well as alert testers to the situation.
While it is possible to have a human observe the test and wait for an error condition to trigger, the length of time that
a fuzzing run requires to complete makes this solution impractical.

The first, and simplest, option is to send a ``heartbeat signal'' to the target, such as an ICMP echo request. While this
solution is simple to implement, it does not offer much information about the nature of the error condition except that the
target no longer responds. In addition, it may miss subtler error conditions that do not result in the outright failure
of the target.

The second method is to attach some manner of debugging agent to the target. In desktop or server applications, this is typically
a debugger that is similar in functionality to gdb or OllyDBG. If a buffer overflows, or if program flow data are otherwise
corrupted (usually indicating an exploitable condition), the attached debugger will catch this signal from the operating system.

\subsection{Fuzzing Frameworks}

Fuzzing frameworks are designed to take some of the manual effort out of designing a testing harness for a given application.
Most have a domain-specific language in which data templates are defined, some method for interfacing with a debugging interface
to monitor the target application, and some kind of business logic for tying all of the fuzzer functions together.

The prototypical fuzzing framework, from which all block-based fuzzers inherit today, was SPIKE. Recognizing that most network protocols
are built of similar parts, SPIKE pioneered the use of pre-made blocks to construct testing frameworks for different network protocols.
It is implemented as a C API that provides what is essentially a domain-specific language that compiles directly to C.

The next big fuzzing framework was Sulley, developed by Pedram Amini of Tipping Point Security. The concept of data generation was similar
to that used by SPIKE, though it did contribute some innovations such as the concept of a ``Lego'' that aids in building up complex
protocol models using smaller parts. The real innovation of Sulley was the integration of separate process and network monitoring agents
that communicate with the central business logic using a simple text-based RPC protocol. This allows for a very flexible and modular
framework with very fine granularity of control. Best of all, it is implemented in the Python programming language, which not only
allows for rapid development of testing templates but also allows for rapid and easy modification and extension of the framework
itself.

The newest, and most complex, framework is Peach, developed by [someone] at IOActive. Like Sulley, it is written in the Python programming
language for rapid development and deployment. One improvement over Sulley is its \emph{incredibly} modular structure: data generation,
data transmission, and fault detection are all abstracted into classes such as Generators and Publishers. This allows many different
transmission media to be used to transmit data, whereas Sulley only supports Ethernet protocols. However, with this increased modularity
comes greater complexity of design and implementation, and the project (at the time of this writing) is poorly-documented. Therefore,
it was foregone as a basis for MoFASA.

The Sulley fuzzing framework was chosen for this project because of the author's prior familiarity with the framework. Sulley
not only includes an easy interface to a lightweight debugging interface using the Pai Mai reverse engineering toolkit, but
also leverages Pai Mai to include stack traces from crashed applications in order to aid in exploitation of discovered
vulnerabilities. In addition to a software debugging module, it also allows one to create additional fault detection modules
implementing heartbeat network signals. Finally, it offers convenient means to monitor testing progress, including a web interface
and a module which sends an e-mail to the researcher whenever it detects a crash.

\section{Programmable Logic Controllers (PLCs)}

The focus of the MOFASA project is auditing embedded computers known as Programmable Logic Controllers, or PLCs.
Originally, engineers implemented process control automation logic using hard-wired panels of relays that
acted as primitive computers. Gradually, these hard-wired relay boxes were replaced by small programmable computers
that performed the same simple calculations as the relay boxes had. To this day, they are programmed using a 
graphical programming language called ``ladder logic'' that mimics the relay boards of the past.

[insert PLC diagram here]

As industrial processes grew in complexity, new and better PLCs were developed with more computing power. Today,
PLCs run on architectures such as ARM or even x86, run embedded operating systems, and implement remote services
such as FTP, HTTP, and remote shells. This increased functionality presents a greater attack surface than PLCs
in the past, and the increased computing power of PLCs can be leveraged to exploit vulnerabilities in far more malicious
ways than was possible even 15 years ago.

\section{Process Contol Protocols}
Process control protocols are (typically) simple binary protocols that PLCs use to communicate with each other and with
devices upstream. 

\subsection{Modbus}
``Modbus'' is the name for a family of process control protocols that are all variants of the original Modbus protocol developed
by Modicon in 1979. 
\subsection{DNP3}
Words about DNP3

\chapter{Implementation}

\section{The Target}

The target for which MoFASA was developed is a model from ControlMicrosystems' SCADAPack series. This model is particularly suited to
the development of this kind of framework. Its microcontroller's core is an ARM7TDMI, which is powerful enough to support many different
services which may potentially be vulnerable and is also capable of running very complex code. As complex code is more likely to be vulnerable,
this provides more a tempting target for vulnerability analysis. Additionally, it is popular and widely-deployed in industry, most notably in the
oil and natural gas sectors. As such, it provides a good opportunity to prove the worth of the MoFASA system in industrial applications.

\section{Data Generation}

The base framework, Sulley, already implements a robust domain-specific language that allows for the creation of varied test data
in a fairly straightforward fashion. The different data templates are implemented in Sulley's domain-specific language.

\subsection{Modbus}

As expected from a binary protocol so simple as MODBUS, the implementation of a data template for the MODBUS protocol was likewise very
simple. The code for this template is provided in Appendix X.

The aim of this module was to test MODBUS implementations in the general case, rather than a specific application configuration. As such, application
data in the fuzz test cases is simply random data of varying length. This should provide some general code coverage in all applications. Additionally,
the ``full\_range'' flag is set to true for the Function Code block; since some implementations of MODBUS implement custom function codes, this provides
the ability to test custom MODBUS implementations in addition to what is found in the standard.

\subsection{DNP3}

As expected, the increased complexity of the DNP3 protocol lead to a corresponding increase in complexity of the data template used for data generation.

\subsection{FTP}

The file transfer protocol is a very widely-used plaintext protocol for transferring files over networks. The SCADAPack controllers
expose the FTP interface in order to facilitate reading data and configuration files remotely.

One of the features of the Sulley data generation language is that it allows for session-based fuzzing, which allows the framework to
complete a handshake or login process for a given target before generating fuzzed session data. The Sulley framework uses a graph representation
for these multi-stage protocols, and the graph of the FTP session is as follows:

\subsection{Remote Shell}

This particular data template is based on the remote shell commands of the Control Microsystems SCADAPack software, which is a fairly
standard Windows-like command shell that communicates over Telnet.The different commands
are specified, along with the appropriate number of arguments. Arguments are fuzzed by inserting large numbers of delimiters, testing numerical
arguments close to the likely overflow boundaries of their data types, and testing unusually large string arguments.

Initially, only commands listd in Control Microsystems' documentation were included in this part of the testing framework. However, reverse-engineering
discovered additional commands that are not included in the documentation; it is likely that these commands are implemented by the underlying embedded operating
system. The reverse-engineering process was fairly simple: after using the \texttt{deezee} utility from Matasano Security's Black Bag series of tools to
extract any compressed portions of the firmware image (there were none), the firmware image was simply scanned for the word ``usage'' using the UNIX
utility \texttt{grep}. Surprisingly, this simple procedure revealed 10 previously-unknown commands, along with prototypes indicating their proper
invocation.

The function prototypes that this simple reverse-engineering process revealed were used to generate data templates for each individual command, based on 
the number and type of arguments expected for each command. Where possible, these templates were made more accurate based on SCADAPack documentation and/or
documentation of the underlying embedded operating system.

\section{Fault Detection}

\subsection{Heartbeat Signals}

Though heartbeat signals are the most primitive form of fault detection, they were implemented as part of MoFASA in order to provide SOME feedback during
testing conducted while more advanced methods were still being developed, and also to allow testing by those who are unable to implement more advanced
fault detection methods on their own.

Heartbeat signals were implemented using several different layers of the communication networking stack. This approach was chosen because, in some systems that
use a process-per-protocol model, failures at different levels of the system may cause unresponsive behavior in some protocols but not others. At the lowest level 
was an ARP heartbeat, implemented similarly to the ARPing security tool. At the next highest level, the heartbeat signal is a standard ICMP echo request used by
the networking utility \texttt{ping}. Above that is a TCP SYN request, implemented using the same technique that the tool \texttt{nmap} uses to perform a SYN scan.

\subsection{Debugging Agent}

As heartbeat signals are imprecise at best, and totally miss error conditions at worst, a hardware debugging agent needed to be integrated into the system if any real
progress was to be made. Embedded computers most commonly use a standard JTAG interface as their hardware debug port. The JTAG interface allows total control over the
system under test, including reading of arbitrary memory locations and execution of arbitrary commands. Forensic experts frequently use the JTAG interface to
read information from ARM-based cellular phones, so there is an academic body of work that was useful in this endeavor.

The specific hardware debugger that was chosen for this project was the Segger J-Link ARM debugger. In addition to its well-documented user API, it was also available
at an academic discount for a very reasonable price. These two factors made it ideal for the development of MoFASA.

In any kind of hardware security/forensic application of the JTAG interface, the first step is to locate the JTAG headers on the board. In many cases, this represents
a significant challange as manufacturers obfuscate their JTAG headers in order to interfere with reverse-engineering or hacking attempts by end users.
Luckily, the CMI SCADAPacks have a 10-pin JTAG header conveniently placed on the board, presumably for in-house testing purposes, and it fit the debug cable on the Segger
unit perfectly. Initially, however, the JTAG debugger could not connect with the ARM core on the chip. Initial reverse-engineering efforts, involving reading the ARM7TDMI
documentation and attempting to follow traces on the circuit board to determine how to switch on the debugging capability of the ARM core, proved fruitless. A far lower-tech
reverse-engineering technique was adopted. First, it was assumed that since the header itself was easily accessible on the board, it must have been provided so that
a field technician could easily access the port for debugging/reflashing. Therefore, the means for toggling the debug port must have also been an easily accessible
device such as a switch or jumper. Examination of the SCADAPack documentation revealed all of the jumpers whose purpose Control Microsystems saw fit to document; all
of these were eliminated as candidates. This left a few remaining jumpers, which were then systematically tested for their effects on the system. Eventually, one jumper
position enabled the debugging feature of the JTAG port.

The integration of the debugger into the framework was fairly straightforward. Segger ships a GDB server with the JTAG ARM debugger which allows for remote debugging of
ARM devices. This server, combined with GDB's scripting interface, allowed the hardware debugger to be fairly simply integrated into the Sulley framework using the 
instrumentation library.

The ARM7 processor family uses an interrupt vector table to handle exceptions, which are at constant memory offsets in most implementations. Therefore, placing a breakpoint
on each of the appropriate interrupt vectors allowed the JTAG debugger to monitor any exception conditions that occurred. 

\section{Testing Setup}

The testing setup involved one physical PC with two virtual machines running on it. The first virtual machine ran the business logic portion of the fuzzing framework,
and ran on top of Backtrack Linux. Additionally, it performed the network heartbeat functions for fault detection.
The second virtual machine managed the JTAG connection to the PLC and ran both the hardware fault detection module and the network traffic monitoring agent.

[insert a picture here]

\chapter{Results and Conclusions}

\section{Heartbeat Signals}

Results of testing the devices vindicated the idea of using multiple heartbeat signals at different levels of the networking stack. During fuzz testing,
initial runs using only an ICMP Echo heartbeat showed that the device was capable of responding to Echo requests but would reject connections to the service
being tested.

Reverse-engineering of the firmware revealed that the SCADAPack 350E runs on top of the u-velOSity real-time microkernel by Green Hills Software. The
u-velOSity operating system works by organizing system functions into multiple tasks, which are then run independently of one another in isolation.
The results from testing indicate that each service (MODBUS, DNP3, FTP, etc) is run as its own task; when the process memory space for a given task
is corrupted, the operating system (or another task) is capable of responding to some heartbeat signals.

\section{Vulnerabilities}

MoFASA discovered vulnerabilities in multiple network interfaces on the SCADAPack 350E, both in ``simple'' binary protocols and more complex
text-based applications.

\subsection{MODBUS}

MoFASA discovered an error condition in the 350E's MODBUS interface rather quickly. When the device receives a request with a ``read multiple coils''
function code with a payload that is far larger than the ``length'' field allows, it triggers an error condition that locks up the MODBUS interface
and requires a device restart to restore functionality. 

Given the nature of the data that triggers the error condition, it is likely that this is a buffer-overflow vulnerability in the MODBUS interface.
While the exploitability of this vulnerability is beyond the scope of this project, it seems likely that this vulnerability could be leveraged
to gain control of the device. At the very least, it is an effective denial-of-service attack on the PLC.

\subsection{Remote Shell}

A remote shell command was found to be vulnerable to either a buffer overflow or a format string attack. The test case shows a large attack string consisting
of the character \texttt{\%}, which would seem to indicate either possibility.

The impact of this vulnerability may be less serious than the MODBUS vulnerability; leaving the MODBUS interface open is necessary to the proper operation of
the device if MODBUS is to be used as a control protocol, while it would be a careless system administrator indeed who left remote shell access open to anyone.
However, if an administrator does leave the interface open, it is entirely feasible that an attacker could use this vulnerability to escalate privilege and
compromise essential functions of the device.



\chapter{Future Work}
\section{Attack Surface}
\subsection{Current Target}
The current target has some attack surfaces that were not probed during MoFASA's development, namely the DHCP and BOOTP interfaces.
Both of these are systems that make a request, and then act on replies to that request, rather than servicing requests themselves.
As such, it would require modification to the way that Sulley operates in order to make it operate as a ``trigger fuzzer,'' receiving
a request and delivering a malformed reply based on the input. Not only that, but it would require implementation of some kind of hardware
functionality to power cycle the PLC, as DHCP and BOOTP configuration are most often only performed on startup.
\subsection{Other Targets}
While the SCADAPack against which MoFASA was run can run many services, there are many more services that run on more full-featured PLCs.
These include web configuration interfaces, OPC servers, and more. These offer tempting targets to an attacker, and the complexity
of implementation of these protocols increases the likelihood of hidden vulnerabilities lurking in these interfaces.
\subsection{Transmission Media}
This research focused entirely on protocols transmitted using TCP/IP over wired Ethernet connections. Many process control implementations still
use RS-232 or RS-485 serial connections; while these are non-routable, and thus more difficult to access than an Ethernet LAN, it may still be possible
to tap such a network and inject traffic into it, and so this attack vector should be explored. Additionally, with the introduction of smart meters into
critical infrastructures, wireless protocols such as Zigbee are beginning to figure prominently in the attack surface of the national utility infrastructure.
Future work could see incorporation of a Zigbee device as a transmission medium for testing devices such as smart meters or home automation controllers.

\section{Search-based Software Testing}
The current state of the art in vulnerability discovery for traditional (workstation/server based) software applications is using search-based methods to
guide test case generation, turning the black-box art of fuzzing into a more gray-box testing methodology. There are several examples of this in the literature.
Two examples will be given here.
\subsection{Evolutionary Fuzzing}
The genetic algorithm is a search method which harnesses the mechanism of natural selection to derive solutions to search problems. One or more populations of
candidate solutions ("chromosomes) are generated and maintained. Then, a heuristic function (called a ``fitness function'') is applied to the candidate solutions to rank them
in terms of their worth as a solution to the given problem (their ``fitness''). The solutions are then ``bred'' with each other to, in theory, produce more
fit offspring. This process is repeated many times, sometimes tens of thousands of times. In practice, this results in very good solutions to many problems.

In [citation], [name] applied genetic algorithms to software testing in an interesting way. He implemented automatic scripts that leveraged
the popular disassembler/debugger IDA Pro to identify basic blocks of machine code that formed the larger application. The framework then places breakpoints on each of the
basic blocks, and tracks which breakpoints are hit in order to track code coverage. Afterwards, a population of test cases is somewhat-randomly generated and then
submitted to the target. The framework tracks the code coverage of each test case, and uses that as the fitness function to generate new test cases. In this way,
the framework is actually capable of learning proprietary binary protocols and testing them with (comparatively) minimal intervention from a developer. The results
described in the paper are promising.

Application to embedded platforms would require some extra work, though the basic technique would remain the same. First off, a method of pulling the firmware off of
the device in question would need to be perfected. The JTAG port could easily be used for this purpose. However, as PLCs are real-time devices, they are frequently
equipped with ``watchdog timers'' that reset the device if operations happen too slowly, and the watchdog timer frequently interferes with memory reads, so this obstacle
would need to be overcome to apply this technique to PLCs. Secondly, disassembling embedded device firmware is a somewhat more complicated process than disassembling
a single user application as the PLC is running an embedded operating system, different parts of which may need to be isolated and identified in order to properly
guide data generation.
\subsection{Statically-Driven Testing}


\end{document}
